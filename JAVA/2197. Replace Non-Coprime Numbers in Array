class Solution {

    private HashMap<String, Integer> gcdMemo = new HashMap<String, Integer>();
    private HashMap<String, Integer> lcmMemo = new HashMap<String, Integer>();


    private int gcd(int a, int b) {
        String key = a < b ? a + "," + b : b + "," + a;
        if (gcdMemo.containsKey(key)) {
            return gcdMemo.get(key);
        }

        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }

        int result = Math.abs(a);
        gcdMemo.put(key, result);
        return result;
    }

    private int lcm(int a, int b, int gcd) {
        String key = a < b ? a + "," + b : b + "," + a;
        if (lcmMemo.containsKey(key)) {
            return lcmMemo.get(key);
        }

        if (a == 0 || b == 0) {
            return 0;
        }

        int result = Math.abs(a * (b / gcd));
        lcmMemo.put(key, result);
        return result;
    }

    private List<Integer> helperStack(List<Integer> nums, int n) {
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);

            // Keep merging with top of stack while GCD > 1
            while (!stack.isEmpty()) {
                int top = stack.peek();
                int g = gcd(top, num);
                if (g > 1) {
                    num = lcm(top, num, g);
                    stack.pop();
                } else {
                    break;
                }
            }

            stack.push(num);
        }

        return new ArrayList<>(stack);
    }


    public List<Integer> replaceNonCoprimes(int[] nums) {
        
        List<Integer> list = new ArrayList<Integer>();
        for(int i:nums)
            list.add(i);

        return helperStack(list, list.size());
    }
}
